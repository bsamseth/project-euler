/*
Each of the six faces on a cube has a different digit (0 to 9) written on it;
the same is done to a second cube. By placing the two cubes side-by-side in
different positions we can form a variety of 2-digit numbers.

In fact, by carefully choosing the digits on both cubes it is possible to
display all of the square numbers below one-hundred: 01, 04, 09, 16, 25, 36,
49, 64, and 81.

For example, one way this can be achieved is by placing {0, 5, 6, 7, 8, 9} on
one cube and {1, 2, 3, 4, 8, 9} on the other cube.

However, for this problem we shall allow the 6 or 9 to be turned upside-down so
that an arrangement like {0, 5, 6, 7, 8, 9} and {1, 2, 3, 4, 6, 7} allows for
all nine square numbers to be displayed; otherwise it would be impossible to
obtain 09.

In determining a distinct arrangement we are interested in the digits on each
cube, not the order.

    {1, 2, 3, 4, 5, 6} is equivalent to {3, 6, 4, 1, 2, 5}
    {1, 2, 3, 4, 5, 6} is distinct from {1, 2, 3, 4, 5, 9}

But because we are allowing 6 and 9 to be reversed, the two distinct sets in
the last example both represent the extended set {1, 2, 3, 4, 5, 6, 9} for the
purpose of forming 2-digit numbers.

How many distinct arrangements of the two cubes allow for all of the square
numbers to be displayed?


Solution comment: Overly generalized solution. Simple in Python using
                  itertools.combinations. Implemented by hand here, with
                  some templating for good measure. Fast, ~10ms.
*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
#include <utility>
#include <chrono>
#include <cassert>

/*
 * Class used to generate all possible dice with
 * eyes selected from [0, N-1], with R sides.
 */
template<int N, int R>
class DiceCombinations {
    static_assert(N >= R, "Must have N >= R.");
private:
    std::array<int, R> _dice;
    std::array<bool, N> _v;

    /*
     * Set the dice eyes based on _v.
     * If _v[i] is selected, then i goes on the dice.
     */
    void set_dice() {
        int curr = 0;
        for (int i = 0; i < N; i++) {
            if (_v[i])
                // Treat every 9 as a 6.
                _dice[curr++] = i == 9 ? 6 : i;
        }
        assert(curr == R);  // _v should have R true's
    }
public:
    DiceCombinations() : _dice(), _v() {
        // _v is true for every digit to select on the dice.
        // Every dice is generated by permuting the selected digits.
        // Initialized by selecting the first R digits.
        std::fill(_v.begin(), _v.begin() + R, true);
        set_dice();
    }
    bool next_dice() {
        // Generate a new dice. Return true if the dice
        // is new, false if it is the initial dice.
        bool has_more = std::prev_permutation(_v.begin(), _v.end());
        set_dice();
        return has_more;
    }
    const auto& get_dice() {
        return _dice;
    }
};

template<typename Iterator>
bool valid_dice_combo(Iterator d1_first, Iterator d1_end, Iterator d2_first, Iterator d2_end) {
    // All of the following pairs must be present in d1 and d2. 6 = 9, so 49 and 64 are equal.
    constexpr std::array<std::pair<int, int>, 8> squares {
        {
            {0, 1}, {0, 4}, {0, 6}, {1, 6}, {2, 5}, {3, 6}, {4, 6}, {8, 1}
        }
    };

    for (const auto [a, b] : squares) {  // Such sweet C++17 features!
        if (not (
                 (std::find(d1_first, d1_end, a) != d1_end and std::find(d2_first, d2_end, b) != d2_end) or
                 (std::find(d1_first, d1_end, b) != d1_end and std::find(d2_first, d2_end, a) != d2_end)
                ))
            // If a pair is not present, return false.
            return false;
    }
    return true;
}

int main() {
    constexpr auto n = 10, r = 6;
    int counter = 0;

    auto start = std::chrono::high_resolution_clock::now();

    // First dice.
    DiceCombinations<n, r> first;
    do {
        const auto &d1 = first.get_dice();

        // Dice content is sorted, and 0 must be present in one of the dice.
        // Stop searching when 0 is not the first element.
        if (d1[0] != 0)
            break;

        // Second dice. Let it always be "larger" than first. That way, the pair of
        // dice (d1, d2) does not appear later as (d2, d1). We do this easily by
        // starting the combination generator at the same state as first is at currently.
        DiceCombinations<n, r> second = first;
        do {
            const auto &d2 = second.get_dice();

            if (valid_dice_combo(d1.begin(), d1.end(), d2.begin(), d2.end()))
                counter++;

        } while (second.next_dice());
    } while (first.next_dice());

    auto end = std::chrono::high_resolution_clock::now();
    auto time = std::chrono::duration_cast<std::chrono::nanoseconds> (end - start) / (double) 1e6;
    printf("Answer: %d\n", counter);
    printf("Found in time: %g ms\n", time);

    return 0;
}
